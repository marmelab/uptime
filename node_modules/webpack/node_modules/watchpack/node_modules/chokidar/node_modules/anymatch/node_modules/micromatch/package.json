{
  "name": "micromatch",
  "description": "Glob matching for javascript/node.js. A drop-in replacement and faster alternative to minimatch and multimatch. Just use `micromatch.isMatch()` instead of `minimatch()`, or use `micromatch()` instead of `multimatch()`.",
  "version": "2.1.6",
  "homepage": "https://github.com/jonschlinkert/micromatch",
  "author": {
    "name": "Jon Schlinkert",
    "url": "https://github.com/jonschlinkert"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jonschlinkert/micromatch.git"
  },
  "bugs": {
    "url": "https://github.com/jonschlinkert/micromatch/issues"
  },
  "license": {
    "type": "MIT",
    "url": "https://github.com/jonschlinkert/micromatch/blob/master/LICENSE"
  },
  "files": [
    "index.js",
    "lib/"
  ],
  "main": "index.js",
  "engines": {
    "node": ">=0.10.0"
  },
  "scripts": {
    "test": "mocha",
    "prepublish": "browserify -o browser.js -e index.js"
  },
  "dependencies": {
    "arr-diff": "^1.0.1",
    "braces": "^1.8.0",
    "debug": "^2.1.3",
    "expand-brackets": "^0.1.1",
    "filename-regex": "^2.0.0",
    "is-glob": "^1.1.3",
    "kind-of": "^1.1.0",
    "object.omit": "^0.2.1",
    "parse-glob": "^3.0.0",
    "regex-cache": "^0.4.0"
  },
  "devDependencies": {
    "benchmarked": "^0.1.3",
    "browserify": "^9.0.3",
    "chalk": "^1.0.0",
    "minimatch": "^2.0.1",
    "minimist": "^1.1.0",
    "mocha": "^2.1.0",
    "multimatch": "^2.0.0",
    "should": "^5.0.1",
    "write": "^0.1.1"
  },
  "keywords": [
    "bash",
    "expand",
    "expansion",
    "expression",
    "file",
    "files",
    "filter",
    "find",
    "glob",
    "globbing",
    "globs",
    "globstar",
    "match",
    "matcher",
    "matches",
    "matching",
    "minimatch",
    "multimatch",
    "path",
    "pattern",
    "patterns",
    "regex",
    "regexp",
    "regular",
    "shell",
    "wildcard"
  ],
  "verb": {
    "deps": {
      "ignore": [
        "browser.js"
      ]
    }
  },
  "readme": "# micromatch [![NPM version](https://badge.fury.io/js/micromatch.svg)](http://badge.fury.io/js/micromatch)  [![Build Status](https://travis-ci.org/jonschlinkert/micromatch.svg)](https://travis-ci.org/jonschlinkert/micromatch) \n\n> Glob matching for javascript/node.js. A drop-in replacement and faster alternative to minimatch and multimatch. Just use `micromatch.isMatch()` instead of `minimatch()`, or use `micromatch()` instead of `multimatch()`.\n\n## Features\n\nMicromatch is [10-55x faster](#benchmarks) than [minimatch], resulting from a combination of caching, tokenization, parsing, runtime compilation and regex optimization strategies.\n\n- [Drop-in replacement][switch] for [minimatch] and [multimatch]\n- Built-in support for multiple glob patterns, like `['foo/*.js', '!bar.js']`\n- Better support for the Bash 4.3 specification, and less buggy\n- Extensive [unit tests](./test) (approx. 1,300 tests). Minimatch fails many of the tests.\n\n**Supports**\n\nMainstream glob features:\n\n + [Brace Expansion][braces] (`foo/bar-{1..5}.md`, `one/{two,three}/four.md`)\n + Typical glob patterns, like `**/*`, `a/b/*.js`, or `['foo/*.js', '!bar.js']`\n\nExtended globbing features:\n\n + Logical `OR` (`foo/bar/(abc|xyz).js`)\n + Regex character classes (`foo/bar/baz-[1-5].js`)\n + POSIX bracket expressions (`**/[[:alpha:][:digit:]]/`)\n + extglobs (`**/+(x|y)`, `!(a|b)`, etc)\n\nYou can combine these to create whatever matching patterns you need.\n\n## Install with [npm](npmjs.org)\n\n```bash\nnpm i micromatch --save\n```\n\n## Usage\n\n```js\nvar mm = require('micromatch');\nmm(array, patterns);\n```\n\n**Examples**\n\n```js\nmm(['a.js', 'b.md', 'c.txt'], '*.{js,txt}');\n//=> ['a.js', 'c.txt']\n```\n\n**Multiple patterns**\n\nMultiple patterns can also be passed:\n\n```js\nmm(['a.md', 'b.js', 'c.txt', 'd.json'], ['*.md', '*.txt']);\n//=> ['a.md', 'c.txt']\n```\n\n**Negation patterns:**\n\n```js\nmm(['a.js', 'b.md', 'c.txt'], '!*.{js,txt}');\n//=> ['b.md']\n\nmm(['a.md', 'b.js', 'c.txt', 'd.json'], ['*.*', '!*.{js,txt}']);\n//=> ['a.md', 'd.json']\n```\n\n## Switch from minimatch\n\n> Use `micromatch.isMatch()` instead of `minimatch()`\n\n**Minimatch**\n\nThe main `minimatch()` function returns true/false for a single file path and pattern:\n\n```js\nvar minimatch = require('minimatch');\nminimatch('foo.js', '*.js');\n//=> 'true'\n```\n\n**Micromatch**\n\nUse `.isMatch()` to get the same result:\n\n\n```js\nvar mm = require('micromatch');\nmm.isMatch('foo.js', '*.js');\n//=> 'true'\n```\n\nThis implementation difference is necessary since the main `micromatch()` method supports matching on multiple globs, with behavior similar to [multimatch].\n\n\n## Methods\n\n```js\nvar mm = require('micromatch');\n```\n\n### .isMatch\n\n```js\nmm.isMatch(filepath, globPattern);\n```\n\nReturns true if a file path matches the given glob pattern.\n\n\n**Example**\n\n```js\nmm.isMatch('.verb.md', '*.md');\n//=> false\n\nmm.isMatch('.verb.md', '*.md', {dot: true});\n//=> true\n```\n\n### .contains\n\nReturns true if any part of a file path matches the given glob pattern. Think of this is \"has path\" versus \"is path\".\n\n**Example**\n\n`.isMatch()` would return false for both of the following:\n\n```js\nmm.contains('a/b/c', 'a/b');\n//=> true\n\nmm.contains('a/b/c', 'a/*');\n//=> true\n```\n\n### .matcher\n\nReturns a function for matching using the supplied pattern. e.g. create your own \"matcher\". The advantage of this method is that the pattern can be compiled outside of a loop.\n\n**Pattern**\n\nCan be any of the following:\n\n- `glob/string`\n- `regex`\n- `function`\n\n**Example**\n\n```js\nvar isMatch = mm.matcher('*.md');\nvar files = [];\n\n['a.md', 'b.txt', 'c.md'].forEach(function(fp) {\n  if (isMatch(fp)) {\n    files.push(fp);\n  }\n});\n```\n\n### .filter\n\nReturns a function that can be passed to `Array#filter()`. \n\n**Params**\n\n- `patterns` **{String|Array}**: \n\n**Examples**\n\nSingle glob:\n\n```js\nvar fn = mm.filter('*.md');\n['a.js', 'b.txt', 'c.md'].filter(fn);\n//=> ['c.md']\n\nvar fn = mm.filter('[a-c]');\n['a', 'b', 'c', 'd', 'e'].filter(fn);\n//=> ['a', 'b', 'c']\n```\n\nArray of glob patterns:\n\n```js\nvar arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n\nvar fn = mm.filter(['{1..10}', '![7-9]', '!{3..4}']);\narr.filter(fn);\n//=> [1, 2, 5, 6, 10]\n```\n\n_(Internally this function generates the matching function by using the [matcher] method. You can use the [matcher] method directly to create your own filter function)_\n\n\n### .any\n\nReturns true if a file path matches any of the given patterns.\n\n```js\nmm.any(filepath, patterns, options);\n```\n\n**Params**\n\n- filepath `{String}`: The file path to test.\n- patterns `{String|Array}`: One or more glob patterns\n- options: `{Object}`: options to pass to the `.matcher()` method.\n\n\n**Example**\n\n```js\nmm.any('abc', ['!*z']);\n//=> true\nmm.any('abc', ['a*', 'z*']);\n//=> true\nmm.any('abc', 'a*');\n//=> true\nmm.any('abc', ['z*']);\n//=> false\n```\n\n\n### .expand\n\nReturns an object with a regex-compatible string and tokens.\n\n```js\nmm.expand('*.js');\n\n// when `track` is enabled (for debugging), the `history` array is used\n// to record each mutation to the glob pattern as it's converted to regex\n{ options: { track: false, dot: undefined, makeRe: true, negated: false },\n  pattern: '(.*\\\\/|^)bar\\\\/(?:(?!(?:^|\\\\/)\\\\.).)*?',\n  history: [],\n  tokens:\n   { path:\n      { whole: '**/bar/**',\n        dirname: '**/bar/',\n        filename: '**',\n        basename: '**',\n        extname: '',\n        ext: '' },\n     is:\n      { glob: true,\n        negated: false,\n        globstar: true,\n        dotfile: false,\n        dotdir: false },\n     match: {},\n     original: '**/bar/**',\n     pattern: '**/bar/**',\n     base: '' } }\n```\n\n### .makeRe\n\nCreate a regular expression for matching file paths based on the given pattern:\n\n```js\nmm.makeRe('*.js');\n//=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n```\n\n## Options\n\nAll options should work the same way as [minimatch].\n\n### options.dot\n\nMatch dotfiles.\n\nType: `{Boolean}`\n\nDefault: `false`\n\n\n### options.matchBase\n\nAllow glob patterns without slashes to match a file path based on its basename.\n\nType: `{Boolean}`\n\nDefault: `false`\n\n**Example**\n\n```js\nmm(['a/b.js', 'a/c.md'], '*.js');\n//=> []\n\nmm(['a/b.js', 'a/c.md'], '*.js', {matchBase: true});\n//=> ['a/b.js']\n```\n\n### options.nobraces\n\nDon't expand braces in glob patterns.\n\nType: `{Boolean}`\n\nDefault: `false`\n\n\n### options.nocase\n\nUse a case-insensitive regex for matching files.\n\nType: `{Boolean}`\n\nDefault: `false`\n\n\n### options.nonull\n\nIf `true`, when no matches are found the actual (array-ified) glob pattern is returned instead of an empty array.\n\nType: `{Boolean}`\n\nDefault: `false`\n\n\n### options.cache\n\nCache the platform (e.g. `win32`) to prevent this from being looked up for every fil.\n\nType: `{Boolean}`\n\nDefault: `true`\n\n\n## Other features\n\nMicromatch also supports the following.\n\n### Extended globbing\n\nExtended globbing as described by the bash man page:\n\n| **pattern** | **regex equivalent** | **description** |\n| --- | --- | --- |\n| `?(pattern-list)` | `(...|...)?` |  Matches zero or one occurrence of the given patterns |\n| `*(pattern-list)` | `(...|...)*` |  Matches zero or more occurrences of the given patterns |\n| `+(pattern-list)` | `(...|...)+` |  Matches one or more occurrences of the given patterns |\n| `@(pattern-list)` | `(...|...)` <sup>*</sup> |  Matches one of the given patterns |\n| `!(pattern-list)` | N/A |  Matches anything except one of the given patterns |\n\n<sup><strong>*</strong></sup> `@` isn't a RegEx character.\n\n\n### Brace Expansion\n\nIn simple cases, brace expansion appears to work the same way as the logical `OR` operator. For example, `(a|b)` will achieve the same result as `{a,b}`.\n\nHere are some powerful features unique to brace expansion (versus character classes):\n\n - range expansion: `a{1..3}b/*.js` expands to: `['a1b/*.js', 'a2b/*.js', 'a3b/*.js']`\n - nesting: `a{c,{d,e}}b/*.js` expands to: `['acb/*.js', 'adb/*.js', 'aeb/*.js']`\n\n\nLearn about [brace expansion][braces], or visit [braces][braces] to ask questions and create an issue related to brace-expansion, or to see the full range of features and options related to brace expansion.\n\n\n### Regex character classes\n\nWith the exception of brace expansion (`{a,b}`, `{1..5}`, etc), most of the special characters convert directly to regex, so you can expect them to follow the same rules and produce the same results as regex.\n\nFor example, given the list: `['a.js', 'b.js', 'c.js', 'd.js', 'E.js']`:\n\n - `[ac].js`: matches both `a` and `c`, returning `['a.js', 'c.js']`\n - `[b-d].js`: matches from `b` to `d`, returning `['b.js', 'c.js', 'd.js']`\n - `[b-d].js`: matches from `b` to `d`, returning `['b.js', 'c.js', 'd.js']`\n - `a/[A-Z].js`: matches and uppercase letter, returning `['a/E.md']`\n\nLearn about [regex character classes][character-classes].\n\n### Regex groups\n\nGiven `['a.js', 'b.js', 'c.js', 'd.js', 'E.js']`:\n\n - `(a|c).js`: would match either `a` or `c`, returning `['a.js', 'c.js']`\n - `(b|d).js`: would match either `b` or `d`, returning `['b.js', 'd.js']`\n - `(b|[A-Z]).js`: would match either `b` or an uppercase letter, returning `['b.js', 'E.js']`\n\nAs with regex, parenthese can be nested, so patterns like `((a|b)|c)/b` will work. But it might be easier to achieve your goal using brace expansion.\n\n## Notes\n\nWhenever possible parsing behavior for patterns is based on globbing specifications in Bash 4.3. Patterns that aren't described by Bash follow wildmatch spec (used by git).\n\n\n## Benchmarks\n\nRun the [benchmarks](./benchmark):\n\n```bash\nnpm run benchmark\n```\n\nAs of March 27, 2015:\n\n```bash\n#1: basename-braces\n  micromatch x 27,734 ops/sec ±0.75% (93 runs sampled)\n  minimatch x 3,409 ops/sec ±0.77% (97 runs sampled)\n\n#2: basename\n  micromatch x 26,727 ops/sec ±0.81% (97 runs sampled)\n  minimatch x 4,122 ops/sec ±0.77% (97 runs sampled)\n\n#3: braces-no-glob\n  micromatch x 324,367 ops/sec ±0.62% (95 runs sampled)\n  minimatch x 29,682 ops/sec ±0.71% (94 runs sampled)\n\n#4: braces\n  micromatch x 63,430 ops/sec ±1.14% (95 runs sampled)\n  minimatch x 2,749 ops/sec ±0.77% (97 runs sampled)\n\n#5: immediate\n  micromatch x 21,842 ops/sec ±0.66% (98 runs sampled)\n  minimatch x 3,638 ops/sec ±0.66% (97 runs sampled)\n\n#6: large\n  micromatch x 802 ops/sec ±0.58% (96 runs sampled)\n  minimatch x 15.72 ops/sec ±1.25% (42 runs sampled)\n\n#7: long\n  micromatch x 8,061 ops/sec ±0.69% (96 runs sampled)\n  minimatch x 560 ops/sec ±0.71% (90 runs sampled)\n\n#8: mid\n  micromatch x 67,972 ops/sec ±0.78% (93 runs sampled)\n  minimatch x 1,745 ops/sec ±0.87% (96 runs sampled)\n\n#9: multi-patterns\n  micromatch x 25,136 ops/sec ±0.87% (95 runs sampled)\n  minimatch x 1,986 ops/sec ±1.03% (95 runs sampled)\n\n#10: no-glob\n  micromatch x 1,062,274 ops/sec ±0.90% (94 runs sampled)\n  minimatch x 53,150 ops/sec ±0.85% (96 runs sampled)\n\n#11: range\n  micromatch x 270,918 ops/sec ±0.75% (97 runs sampled)\n  minimatch x 13,548 ops/sec ±0.85% (96 runs sampled)\n\n#12: shallow\n  micromatch x 198,022 ops/sec ±0.80% (97 runs sampled)\n  minimatch x 20,093 ops/sec ±0.62% (95 runs sampled)\n\n#13: short\n  micromatch x 440,230 ops/sec ±0.84% (97 runs sampled)\n  minimatch x 58,116 ops/sec ±0.74% (92 runs sampled)\n\n```\n\n## Run tests\nInstall dev dependencies:\n\n```bash\nnpm i -d && npm test\n```\n\n## Contributing\nPull requests and stars are always welcome. For bugs and feature requests, [please create an issue](https://github.com/jonschlinkert/micromatch/issues)\n\nPlease be sure to run the benchmarks before/after any code changes to judge the impact before you do a PR. thanks!\n\n## Related \n * [braces](https://github.com/jonschlinkert/braces): Fastest brace expansion for node.js, with the most complete support for the Bash 4.3 braces specification.\n * [fill-range](https://github.com/jonschlinkert/fill-range): Fill in a range of numbers or letters, optionally passing an increment or multiplier to use.\n * [expand-range](https://github.com/jonschlinkert/expand-range): Fast, bash-like range expansion. Expand a range of numbers or letters, uppercase or lowercase. See the benchmarks. Used by micromatch.\n * [parse-glob](https://github.com/jonschlinkert/parse-glob): Parse a glob pattern into an object of tokens.\n * [is-glob](https://github.com/jonschlinkert/is-glob): Returns `true` if the given string looks like a glob pattern.\n\n## Author\n\n**Jon Schlinkert**\n \n+ [github/jonschlinkert](https://github.com/jonschlinkert)\n+ [twitter/jonschlinkert](http://twitter.com/jonschlinkert) \n\n## License\nCopyright (c) 2014-2015 Jon Schlinkert  \nReleased under the MIT license\n\n***\n\n_This file was generated by [verb-cli](https://github.com/assemble/verb-cli) on March 27, 2015._\n\n[switch]: #switch-from-minimatch\n[multimatch]: https://github.com/sindresorhus/multimatch\n[minimatch]: https://github.com/isaacs/minimatch\n[brace expansion]: https://github.com/jonschlinkert/braces\n[braces]: https://github.com/jonschlinkert/braces\n[bracket expressions]: https://github.com/jonschlinkert/expand-brackets\n[character-classes]: http://www.regular-expressions.info/charclass.html\n[expand]: https://github.com/jonschlinkert/micromatch#expand\n[extended]: http://mywiki.wooledge.org/BashGuide/Patterns#Extended_Globs\n[extglobs]: https://github.com/jonschlinkert/extglob\n<!-- deps:mocha browserify -->\n",
  "readmeFilename": "README.md",
  "_id": "micromatch@2.1.6",
  "_from": "micromatch@^2.1.5"
}
